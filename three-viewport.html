<!--
Copyright 2012 Flux Factory, Inc.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-signals/core-signals.html">
<link rel="import" href="three.html">

<link rel="import" href="three-webglrenderer.html">
<link rel="import" href="three-gridhelper.html">
<link rel="import" href="three-cameracontrols.html">

<!--
Interactive viewport for 3D rendering using THREE.js (http://threejs.org/).

three-viewport provides a simple API for rendering multiple THREE.js scenes into multiple viewports.
Each viewport can have different or shared cameras, tools and camera controls. 

Example:

    <three-viewport camera="persp" gridOrientation="xz" showHelpers="true"></three-viewport>
-->

<!--
@group Flux Elements
@element three-viewport
@blurb Interactive viewport for 3D rendering using THREE.js
@homepage https://bitbucket.org/vannevartech/three-js
@status alpha
-->

<polymer-element name="three-viewport" tabindex="0">
  <template>
    <style type="text/css">
      :host {
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        box-sizing: border-box;
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        -ms-box-sizing: border-box;
        cursor: crosshair;
        position: relative;
      }
      :host(:focus) {
        outline: 0;
      }
      #renderer,
      #outline {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        pointer-events: none;
      }
      :host > #outline {
        border: 1px solid #ddd;
      }
      :host(:focus) > #outline {
        border: 1px solid #aae207;
      }
    </style>
    <core-signals on-core-signal-three-viewport="{{threeViewportSignal}}"></core-signals>
    <three-gridhelper id="grid" orientation="{{gridOrientation}}"></three-gridhelper>
    <three-cameracontrols id="contorls"
      camera="{{camera}}" mode="editor" domElement="{{}}" on-change="{{render}}"
      enabled="{{(!tool || altKey) ? true : false}}">
    </three-cameracontrols>
    <three-webglrenderer id="renderer"
      width="{{width}}" height="{{height}}">
    </three-webglrenderer>
    <div id="outline"></div>
  </template>
  <script type="text/javascript">

    (function() {

      // temporary variables
      var x, y, intersects;
      var cameraWidth, cameraHeight;
      var ray = new THREE.Raycaster();
      var projector = new THREE.Projector();
      var tempV3_0 = new THREE.Vector3();
      var tempV3_1 = new THREE.Vector3();

      Polymer({

        publish: {

          /**
           * Scene to be rendered in this viewport.
           *
           * @attribute scene
           * @type object
           * @default new THREE.Scene()
           */
          scene: null,

          /**
           * Camera to be rendered with.
           * Any instance of `THREE.Camera` can be set here.
           *
           * @attribute camera
           * @type object
           */
          camera: null,

          //TODO
          cameraType: 'persp',

          /**
           * Tool to recieve pointer events from this element.
           * Tool should be an element extending `three-tool` element
           *
           * @attribute tool
           * @type element
           */
          tool: null,

          /**
           * Determines if scene helpers are rendered.
           *
           * @attribute showHelpers
           * @type boolean
           * @default true
           */
          showHelpers: true,

          /**
           * Determines orientation of the grid.
           * This attribute is set automatically when cameras are changed.
           *
           * @attribute gridOrientation
           * @type string
           * @default "xz"
           */
          gridOrientation: 'xz',

          /**
           * Background color
           *
           * @attribute clearColor
           * @type object
           * @default new THREE.Color(0xCCCCCC)
           */
          clearColor: null,

          observe: {
            'showHelpers gridOrientation': 'renderLater',
            'camera': 'updateCamera'
          },

        },

        width: null,
        height: null,
        rendered: false,
        shiftKey: false,
        altKey: false,

        ready: function() {

          this._getRay = this.getRay.bind(this);
          this._getPointOnPlane = this.getPointOnPlane.bind(this);
          this._render = this.render.bind(this);
          this._resize = this.resize.bind(this);

          if (!this.scene) this.scene = new THREE.Scene();
          if (!this.clearColor) this.clearColor = new THREE.Color(0xC5CDCC);

          this.viewportHelpers = new THREE.Scene();
          this.$.grid.mesh.name = 'name';
          this.viewportHelpers.add(this.$.grid.mesh);

          this.sceneChanged();
          this.clearColorChanged();
          this.cameraTypeChanged();

        },

        domReady: function() {
          var scope = this;

          this._resize();

          var pointerEvents = [
            'Down',
            'Up',
            'TrackStart',
            'Track',
            'TrackEnd',
            'Tap',
            'MouseMove'
          ];

          var keyEvents = [
            'KeyDown',
            'KeyUp'
          ];

          for (var i = pointerEvents.length; i--;) {
            (function(i) {
              PolymerGestures.addEventListener(scope,
                pointerEvents[i].toLowerCase(),
                function(event) {
                  scope.focus();
                  scope.render();
                  if (!scope.tool || scope.altKey) return;
                  if (scope.tool.constructor.prototype.hasOwnProperty(
                    'on' + pointerEvents[i])) {
                    event.ray = scope._getRay(event);
                    event.pointOnPlane = scope._getPointOnPlane(
                      event.ray, scope.shiftKey);
                    scope.tool['on' + pointerEvents[i]](event);
                  }
                }
              );
            })(i);
          }

          for (var i = keyEvents.length; i--;) {
            (function(i) {
              scope.addEventListener(keyEvents[i].toLowerCase(),
                function(event) {
                  scope.render();
                  if (!scope.tool || scope.altKey) return;
                  if (scope.tool.constructor.prototype.hasOwnProperty(
                    'on' + keyEvents[i])) {
                    scope.tool['on' + keyEvents[i]](event);
                  }
                }
              );
            })(i);
          }

        },

        resize: function() {
          this._rect = this.getBoundingClientRect();
          this._rect.width = Math.floor(this._rect.width);
          this._rect.height = Math.floor(this._rect.height);

          if (this.width != this._rect.width ||
            this.height != this._rect.height)
          {
            this.width = this._rect.width;
            this.height = this._rect.height;
            this.updateCamera();
          }
          requestAnimationFrame(this._resize);
        },

        render: function() {
          if (!this.rendered) {
            this.$.renderer.clear();

            this.$.renderer.render(this.scene, this.camera);
            if (this.showHelpers) {
              this.$.renderer.render(this.viewportHelpers, this.camera);
              this.$.renderer.render(this.scene.helpers, this.camera);
            }

            this.rendered = true;
            requestAnimationFrame(function() {
              this.rendered = false;
            }.bind(this));
          }
        },
        renderLater: function() {
          requestAnimationFrame(this._render);
        },

        clearColorChanged: function() {
          this.$.renderer.setClearColor(this.clearColor);
        },

        sceneChanged: function() {
          if (this.scene.helpers === undefined) {
            this.scene.helpers = new THREE.Scene();
          }
        },

        cameraTypeChanged: function() {
          var camera;
          switch (this.cameraType) {
            case 'front':
              camera = new THREE.OrthographicCamera(-100, 100, 100, -100, -1000, 1000);
              camera.name = 'cameraFront';
              camera.position.set(0, 0, -500);
              camera.rotation.set(0, 0, 0);
              break;
            case 'back':
              camera = new THREE.OrthographicCamera(-100, 100, 100, -100, -1000, 1000);
              camera.name = 'cameraBack';
              camera.position.set(0, 0, 500);
              camera.rotation.set(0, Math.PI, 0);
              break;
            case 'left':
              camera = new THREE.OrthographicCamera(-100, 100, 100, -100, -1000, 1000);
              camera.name = 'cameraLeft';
              camera.position.set(500, 0, 0);
              camera.rotation.set(0, Math.PI / 2, 0);
              break;
            case 'right':
              camera = new THREE.OrthographicCamera(-100, 100, 100, -100, -1000, 1000);
              camera.name = 'cameraRight';
              camera.position.set(-500, 0, 0);
              camera.rotation.set(0, -Math.PI / 2, 0);
              break;
            case 'top':
              camera = new THREE.OrthographicCamera(-100, 100, 100, -100, -1000, 1000);
              camera.name = 'cameraTop';
              camera.position.set(0, 500, 0);
              camera.rotation.set(Math.PI / 2, 0, 0);
              break;
            case 'bottom':
              camera = new THREE.OrthographicCamera(-100, 100, 100, -100, -1000, 1000);
              camera.name = 'cameraBottom';
              camera.position.set(0, -500, 0);
              camera.rotation.set(-Math.PI / 2, 0, 0);
              break;
            case 'persp':
              camera = new THREE.PerspectiveCamera(60, 1, 0.001, 1000);
              camera.name = 'cameraPerspective';
              camera.position.set(25, 25, 25);
              camera.lookAt(new THREE.Vector3(0, 0, 0));
              break;
          }
          this.camera = camera;
        },

        updateCamera: function() {
          if (this.camera instanceof THREE.PerspectiveCamera) {
            this.camera.aspect = this.width / this.height;
          }
          if (this.camera instanceof THREE.OrthographicCamera) {
            this.camera.aspect = this.width / this.height;
            cameraWidth = this.camera.right - this.camera.left;
            cameraHeight = this.camera.top - this.camera.bottom;

            this.camera.top = cameraHeight / 2;
            this.camera.bottom = - cameraHeight / 2;
            this.camera.right = cameraHeight / 2 * this.camera.aspect;
            this.camera.left = - cameraHeight / 2 * this.camera.aspect;
          }
          this.camera.updateProjectionMatrix();
          this.renderLater();
        },

        /**
         * @param {Object} event Pointer event
         * @return {Object} Ray based on current camera
         * @method getRay
         */
        getRay: function(event) {
          x = (event.clientX !== undefined) ? event.clientX : event.x;
          y = (event.clientY !== undefined) ? event.clientY : event.y;
          x = (x - this._rect.left) / this._rect.width * 2 - 1;
          y = - (y - this._rect.top) / this._rect.height * 2 + 1;
          tempV3_0 = new THREE.Vector3(x, y, 0.5);
          this.camera.updateMatrixWorld();
          // matrixWorld 12,13,14 are absolute position.
          tempV3_1 = new THREE.Vector3(
            this.camera.matrixWorld.elements[12],
            this.camera.matrixWorld.elements[13],
            this.camera.matrixWorld.elements[14]
         );
          projector.unprojectVector(tempV3_0, this.camera);
          ray.set(tempV3_1, tempV3_0.sub(tempV3_1).normalize());
          return ray;
        },

        /**
         * @method getRay
         * @param {Object} ray Ray to project on the grid plane
         * @param {Boolean} snap If true, resulting point will snap to nearest grid line crossing
         * @return {Object} THREE.Vector3 representing point of intersection of a ray and grid plane
         */
        getPointOnPlane: function(ray, snap) {
          // TODO(arodic): fix othographic when params on camera not default
          // TODO(arodic): consider removing grid from viewport.
          intersects = ray.intersectObjects([this.$.grid.plane], true);
          if (intersects.length) {
            if (snap) {
              intersects[0].point.x =
                Math.round(intersects[0].point.x / this.$.grid.size) *
                this.$.grid.size;
              intersects[0].point.y =
                Math.round(intersects[0].point.y / this.$.grid.size) *
                this.$.grid.size;
              intersects[0].point.z =
                Math.round(intersects[0].point.z / this.$.grid.size) *
                this.$.grid.size;
            }
            return intersects[0].point;
          }
        },

        /**
         * @method threeViewportSignal
         * This element recieves core-signal-three-viewport and performs action specified
         * in the signal detail. For example, 3D object that changed it's geometry can notify
         * all viewports to perform renderLater action by firing:
         *
         *     `this.fire('core-signal', {name: 'three-viewport', data: {action: 'renderLater'}});`
         */
        threeViewportSignal: function(event) {
          // TODO(aki): Add ability to broadcast to viewports selectively.
          if (event.detail.action !== undefined && typeof this[event.detail.action] === 'function') {
            this[event.detail.action]();
          }
        }
      });

    })();
  </script>
</polymer-element>
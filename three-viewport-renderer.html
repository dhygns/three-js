<link rel="import" href="three.html">

<!--
Element wrapper for the THREE.WebGLRenderer (http://threejs.org/docs/#Reference/Renderers/WebGLRenderer).

It manages GL rendering context across multiple instances of three-viewport.

three-viewport-renderer implements THREE.WebGLRenderer and makes it possible to use
a single WebGL rendering context in multiple [three-viewport](#three-viewport) elements.

@element three-viewport-renderer
@blurb Element wrapper for the THREE.WebGLRenderer
-->

<polymer-element name="three-viewport-renderer">
  <template>
   <link rel="stylesheet" type="text/css" href="three-viewport-renderer.css">
   <div id="outline" fit></div>
  </template>
  <script type="text/javascript">
    (function() {

      var renderer;
      var currentHost;
      var glEnabled = true;
      var gl;

      var ctxPerfNow = 0;
      var ctxPerfDelta = 1000;
      var ctxPerfAverage = 1000;
      var ctxPerfWarned;

      /**
       * This function runs every time renderer migrates to another three-viewport-renderer host
       * It is designed to detect if migration feature is overrused by the user.
       */
      var performanceCheck = function() {
        if (ctxPerfWarned) return;
        ctxPerfDelta = performance.now() - ctxPerfNow;
        ctxPerfAverage = Math.min((ctxPerfAverage * 10 + ctxPerfDelta) / 11, 1000);
        ctxPerfNow = performance.now();
        if (ctxPerfAverage < 16) {
          console.warn('Performance warning: rendering multiple viewports!');
          ctxPerfWarned = true;
        }
      };

      /**
      * Renderer method that will be available on this element as proxy.
      * calling this method will triger renderer migration.
      * @method clear
      * @method setClearColor
      * @method setSize
      * @method render
      */
      var methods = ['clear', 'setClearColor', 'setSize', 'render', 'setViewport'];

      Polymer({
        publish: {
          // THREE.WebGLRenderer attributes
          autoClear: false,
          autoClearColor: false,
          autoClearDepth: false,
          autoClearStencil: false,
          sortObjects: true,
          gammaInput: true,
          gammaOutput: true,
          width: null,
          height: null
        },


        observe: {
          'autoClear': 'update',
          'autoClearColor': 'update',
          'autoClearDepth': 'update',
          'autoClearStencil': 'update',
          'sortObjects': 'update',
          'gammaInput': 'update',
          'gammaOutput': 'update',
          'width height': 'resizeCanvas'
        },

        ready: function() {
          // Canvas2D used to store framebuffer pixels after renderer.domElement migration.
          this.canvas = document.createElement('canvas');
          this.canvas.id = 'canvas';
          this.ctx = this.canvas.getContext('2d');
          this.shadowRoot.insertBefore(this.canvas, this.$.outline);

          // Detect WebGL support
          if (!Detector.webgl) {
            this.shadowRoot.insertBefore(Detector.getWebGLErrorMessage(), this.$.outline);
            glEnabled = false;
            return;
          }

          // Create renderer for the first time.
          if (!renderer) {
            renderer = new THREE.WebGLRenderer({
              antialias: true,
              preserveDrawingBuffer: true,
              alpha: false
            });
            gl = renderer.getContext();
            this.update();
          }

          // Create proxies for renderer methods
          methods.forEach(function(method) {
            this[method] = function() {
              if (!glEnabled) return;
              this.setHost();
              renderer[method].apply(renderer, arguments);
            }
          }.bind(this));

        },

        // Set renderer parameters
        update: function() {
          if (!glEnabled) return;
          renderer.autoClear = this.autoClear;
          renderer.autoClearColor = this.autoClearColor;
          renderer.autoClearDepth = this.autoClearDepth;
          renderer.autoClearStencil = this.autoClearStencil;
          renderer.sortObjects = this.sortObjects;
          renderer.gammaInput = this.gammaInput;
          renderer.gammaOutput = this.gammaOutput;
        },

        // Resize canvas2D automatically
        resizeCanvas: function() {
          this.canvas.width = this.width;// * window.devicePixelRatio;
          this.canvas.height = this.height;// * window.devicePixelRatio;
          this.fire('canvas-resized');
        },

        /**
         * Migrate renderer.domElement to this host if necessary
         * and copy framebuffer into Canvas2D element of the previous host.
         */
        setHost: function() {
          if (!glEnabled) return;
          if (this != currentHost) {
            performanceCheck();
            if (currentHost) {
              currentHost.ctx.drawImage(renderer.domElement, 0, 0, currentHost.canvas.width, currentHost.canvas.height);
              gl.flush();
              currentHost.canvas.style.display = 'block';
              currentHost.currentWidth = null;
              currentHost.currentHeight = null;
            }
            currentHost = this;
            this.setHostSize();
            this.shadowRoot.insertBefore(renderer.domElement, this.$.outline);
            this.canvas.style.display = 'none';
            this.classList.toggle('rendering', true);
            requestAnimationFrame(function() {
              this.classList.toggle('rendering', false);
            }.bind(this));
            this.update();
          }
          this.setHostSize();
        },
        setHostSize: function() {
          if (this.currentWidth != this.width || this.currentHeight != this.height) {
            renderer.setSize(this.width, this.height);
            this.currentWidth = this.width;
            this.currentHeight = this.height;
          }
        },

      });

    })();
  </script>
</polymer-element>